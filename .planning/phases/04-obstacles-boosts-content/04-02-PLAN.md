# Plan 04-02: Remaining Obstacles + Boost System

**Phase:** 04-obstacles-boosts-content
**Scope:** Random Blocks and Sand obstacles, BoostConfig resource, BoostManager, BoostPanel UI, boost-obstacle interactions
**Requirements:** OBST-03, OBST-04, OBST-05, BOST-01 through BOST-06
**Depends on:** 04-01 (ObstacleBase, ObstacleManager, LetterSlot extensions)

---

## Context

With the obstacle architecture from 04-01 in place, this plan adds the two remaining obstacle types and the full boost system. Random Blocks fills slots with blocks; Sand slowly fills slots over time. Each obstacle has a counter-boost, and using a boost without a matching obstacle grants a score bonus.

### Design Decisions

- **Random Blocks visual**: Use a BLOCKED LetterSlot state with brown/wood-grain StyleBoxFlat (no sprite/texture needed yet -- Phase 8 polish adds art assets)
- **Sand visual**: Use a SANDED LetterSlot state with sandy-colored StyleBoxFlat fill. Skip GPU particles for now -- they're Phase 8 polish. The functional mechanic (slot becomes unusable, trickle timer) is what matters.
- **Boost loadout**: Simple pre-level selection. For now, hardcode a loadout of 3 boosts since we don't have a loadout screen yet (Phase 5 adds inventory/loadout screen). Focus on in-game boost activation.
- **Boost panel**: 3 buttons in an HBoxContainer below the HUD during gameplay.

---

## Tasks

### Task 1: Extend LetterSlot with BLOCKED and SANDED states

**File:** `scripts/ui/letter_slot.gd` (EDIT)

Update State enum:
```gdscript
enum State { EMPTY, FILLED, CORRECT, INCORRECT, LOCKED, BLOCKED, SANDED }
```

Add `_style_blocked` and `_style_sanded` StyleBoxFlat in `_create_styles()`:
- BLOCKED: brown bg `Color(0.55, 0.35, 0.15, 1)`, dark brown border
- SANDED: sandy bg `Color(0.85, 0.75, 0.55, 0.8)`, tan border

Add vars:
```gdscript
var _is_blocked: bool = false
var _is_sanded: bool = false
```

Add functions:
```gdscript
func set_blocked(blocked: bool) -> void:
    _is_blocked = blocked
    if blocked:
        set_state(State.BLOCKED)
    else:
        set_state(State.EMPTY)

func set_sanded(sanded: bool) -> void:
    _is_sanded = sanded
    if sanded:
        set_state(State.SANDED)
    else:
        set_state(State.EMPTY)

func can_accept_input() -> bool:
    return not (_is_locked or _is_blocked or _is_sanded)
```

Update `set_state()` match block with BLOCKED and SANDED cases.

### Task 2: Implement RandomBlocksObstacle

**File:** `scripts/gameplay/obstacles/random_blocks_obstacle.gd` (NEW)

```gdscript
class_name RandomBlocksObstacle
extends ObstacleBase

var _blocked_slot_indices: Array[int] = []

func activate() -> void:
    var block_count: int = config.effect_data.get("block_count", randi_range(1, 3))
    _place_blocks(block_count)
    EventBus.obstacle_triggered.emit(config.word_index, "random_blocks")
    obstacle_activated.emit()

func _place_blocks(count: int) -> void:
    # Find empty (non-revealed) slots
    var available: Array[int] = []
    for i in range(_target_word_row._letter_slots.size()):
        var slot = _target_word_row._letter_slots[i]
        if slot.get_letter() == "" and slot.can_accept_input():
            available.append(i)
    available.shuffle()
    var to_block: int = min(count, available.size())
    for i in range(to_block):
        var idx: int = available[i]
        _blocked_slot_indices.append(idx)
        _target_word_row._letter_slots[idx].set_blocked(true)
    # If ALL slots now blocked or filled, auto-solve for 0 points
    if _check_all_blocked():
        _auto_solve_zero()

func _check_all_blocked() -> bool:
    for slot in _target_word_row._letter_slots:
        if slot.can_accept_input() and slot.get_letter() == "":
            return false
    return true

func _auto_solve_zero() -> void:
    # Reveal remaining letters without scoring
    _target_word_row.auto_solve_zero_points()

func clear() -> void:
    for idx in _blocked_slot_indices:
        _target_word_row._letter_slots[idx].set_blocked(false)
    _blocked_slot_indices.clear()
    EventBus.obstacle_cleared.emit(config.word_index, "random_blocks")
    obstacle_cleared.emit()
```

### Task 3: Add auto_solve_zero_points to WordRow

**File:** `scripts/ui/word_row.gd` (EDIT)

Add function:
```gdscript
func auto_solve_zero_points() -> void:
    # Fill all slots with solution letters but award 0 points
    for i in range(_solution_word.length()):
        _letter_slots[i].set_letter(_solution_word[i], false)
        _letter_slots[i].set_state(LetterSlot.State.FILLED)
    _current_index = _solution_word.length()
    # Emit completion but flag it as zero-point
    word_completed.emit()
```

Note: GameplayScreen already multiplies BASE_SCORE * multiplier. We'll add a flag to distinguish zero-point completions in the signal. For simplicity, add a `_zero_point_override` var to WordRow and check it in GameplayScreen.

Actually, cleaner approach: add a `zero_point_completed` signal to WordRow:
```gdscript
signal zero_point_completed
```

And in `auto_solve_zero_points()`, emit `zero_point_completed` instead of `word_completed`.

GameplayScreen connects `zero_point_completed` to a handler that advances without scoring.

### Task 4: Implement SandObstacle

**File:** `scripts/gameplay/obstacles/sand_obstacle.gd` (NEW)

Sand is simpler than the research suggests -- no particles for now (Phase 8 polish):
- On activate, pick 1-5 target words (from config or random)
- Start a Timer that trickles sand into one random slot per tick
- When a slot is sanded, it can't accept input
- If all slots in a word are sanded, word becomes unsolvable

```gdscript
class_name SandObstacle
extends ObstacleBase

var _sanded_slots: Dictionary = {}  # word_index -> Array[int] of slot indices
var _target_word_rows: Array = []  # Array of WordRow refs
var _trickle_timer: Timer
var _trickle_interval: float = 3.0

func setup_multi(obstacle_config: ObstacleConfig, word_rows: Array) -> void:
    config = obstacle_config
    _target_word_rows = word_rows
    _trickle_interval = config.effect_data.get("trickle_interval", 3.0)

func activate() -> void:
    # Pick words to target
    var word_count: int = config.effect_data.get("word_count", randi_range(1, 3))
    var word_indices: Array = config.effect_data.get("word_indices", [])
    if word_indices.is_empty():
        # Random selection from remaining words
        var available: Array[int] = []
        for i in range(_target_word_rows.size()):
            available.append(i)
        available.shuffle()
        for i in range(min(word_count, available.size())):
            word_indices.append(available[i])

    for idx in word_indices:
        _sanded_slots[idx] = []

    # Start trickle timer
    _trickle_timer = Timer.new()
    _trickle_timer.wait_time = _trickle_interval
    _trickle_timer.timeout.connect(_on_trickle)
    add_child(_trickle_timer)
    _trickle_timer.start()

    EventBus.obstacle_triggered.emit(config.word_index, "sand")
    obstacle_activated.emit()

func _on_trickle() -> void:
    if _sanded_slots.is_empty():
        _trickle_timer.stop()
        return
    # Pick a random target word and sand one slot
    var word_indices = _sanded_slots.keys()
    word_indices.shuffle()
    var target_idx: int = word_indices[0]
    if target_idx >= _target_word_rows.size():
        return
    var word_row = _target_word_rows[target_idx]
    var available: Array[int] = []
    for i in range(word_row._letter_slots.size()):
        if not _sanded_slots[target_idx].has(i) and word_row._letter_slots[i].can_accept_input():
            available.append(i)
    if available.size() > 0:
        available.shuffle()
        var slot_idx: int = available[0]
        _sanded_slots[target_idx].append(slot_idx)
        word_row._letter_slots[slot_idx].set_sanded(true)

func clear() -> void:
    # Clear up to 3 words of sand
    var cleared: int = 0
    var keys_to_erase: Array = []
    for word_idx in _sanded_slots.keys():
        if cleared >= 3:
            break
        if word_idx < _target_word_rows.size():
            var word_row = _target_word_rows[word_idx]
            for slot_idx in _sanded_slots[word_idx]:
                if slot_idx < word_row._letter_slots.size():
                    word_row._letter_slots[slot_idx].set_sanded(false)
        keys_to_erase.append(word_idx)
        cleared += 1
    for key in keys_to_erase:
        _sanded_slots.erase(key)
    if _sanded_slots.is_empty() and _trickle_timer:
        _trickle_timer.stop()
    EventBus.obstacle_cleared.emit(config.word_index, "sand")
    obstacle_cleared.emit()
```

### Task 5: Register new obstacle types in ObstacleManager factory

**File:** `scripts/gameplay/obstacle_manager.gd` (EDIT from 04-01)

Ensure the factory match includes `"random_blocks"` and `"sand"`.

For sand obstacles, use `setup_multi()` instead of `setup()` since sand targets multiple words. Add a special case in `_spawn_obstacle()`:
```gdscript
if config.obstacle_type == "sand":
    obstacle.setup_multi(config, _word_rows)
else:
    obstacle.setup(config, _get_word_row(config.word_index))
```

### Task 6: Create BoostConfig resource

**File:** `scripts/resources/boost_config.gd` (NEW)

```gdscript
class_name BoostConfig
extends Resource

@export var boost_id: String = ""  # "lock_key", "block_breaker", "bucket_of_water"
@export var display_name: String = ""
@export var description: String = ""
@export var counters_obstacle: String = ""  # Obstacle type this boost counters
@export var score_bonus: int = 500  # Bonus when used without matching obstacle
```

### Task 7: Create BoostManager

**File:** `scripts/gameplay/boost_manager.gd` (NEW)

```gdscript
class_name BoostManager
extends Node

var _obstacle_manager: Node  # ObstacleManager ref
var _loadout: Array[String] = []
var _used: Array[bool] = []

func setup(obstacle_manager: Node, loadout: Array[String]) -> void:
    _obstacle_manager = obstacle_manager
    _loadout = loadout
    _used.resize(loadout.size())
    _used.fill(false)

func use_boost(index: int, current_word_index: int) -> bool:
    if index >= _loadout.size() or _used[index]:
        return false
    var boost_id: String = _loadout[index]
    _used[index] = true

    var counters := _get_counter_type(boost_id)
    # Check if current word has matching obstacle
    if counters != "" and _obstacle_manager.has_obstacle_type(current_word_index, counters):
        _obstacle_manager.clear_obstacle(current_word_index, boost_id)
        EventBus.boost_used.emit(boost_id, current_word_index)
        return true
    else:
        # No matching obstacle -- grant score bonus
        EventBus.boost_used.emit(boost_id, current_word_index)
        return true  # Caller awards score bonus

func _get_counter_type(boost_id: String) -> String:
    match boost_id:
        "lock_key": return "padlock"
        "block_breaker": return "random_blocks"
        "bucket_of_water": return "sand"
    return ""

func is_boost_used(index: int) -> bool:
    return index < _used.size() and _used[index]

func get_loadout() -> Array[String]:
    return _loadout
```

### Task 8: Create BoostPanel UI

**File:** `scenes/ui/boost_panel.tscn` (NEW)
**File:** `scripts/ui/boost_panel.gd` (NEW)

BoostPanel is an HBoxContainer with 3 Button children. Each button shows the boost name and emits `boost_pressed(index)`.

```gdscript
class_name BoostPanel
extends HBoxContainer

signal boost_pressed(index: int)

var _buttons: Array[Button] = []

func setup(loadout: Array[String]) -> void:
    # Clear existing buttons
    for child in get_children():
        child.queue_free()
    _buttons.clear()

    for i in range(loadout.size()):
        var btn := Button.new()
        btn.text = _get_display_name(loadout[i])
        btn.custom_minimum_size = Vector2(100, 40)
        btn.pressed.connect(_on_button_pressed.bind(i))
        add_child(btn)
        _buttons.append(btn)

func disable_boost(index: int) -> void:
    if index < _buttons.size():
        _buttons[index].disabled = true
        _buttons[index].modulate = Color(0.5, 0.5, 0.5, 0.6)

func _on_button_pressed(index: int) -> void:
    boost_pressed.emit(index)

func _get_display_name(boost_id: String) -> String:
    match boost_id:
        "lock_key": return "Key"
        "block_breaker": return "Breaker"
        "bucket_of_water": return "Water"
    return boost_id
```

### Task 9: Wire BoostPanel and BoostManager into GameplayScreen

**File:** `scenes/screens/gameplay_screen.tscn` (EDIT)

Add BoostPanel node in MainVBox between ScoreHUD and StarBarRow:
```
[node name="BoostPanel" parent="MainVBox" instance=ExtResource("boost_panel")]
unique_name_in_owner = true
layout_mode = 2
```

Add BoostManager node as child of root (like ObstacleManager):
```
[node name="BoostManager" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("boost_manager_script")
```

**File:** `scripts/screens/gameplay_screen.gd` (EDIT)

Add references:
```gdscript
@onready var _boost_manager: Node = %BoostManager
@onready var _boost_panel: HBoxContainer = %BoostPanel
```

In `_ready()`:
```gdscript
# Hardcoded loadout for testing (Phase 5 adds inventory/loadout screen)
var test_loadout: Array[String] = ["lock_key", "block_breaker", "bucket_of_water"]
_boost_manager.setup(_obstacle_manager, test_loadout)
_boost_panel.setup(test_loadout)
_boost_panel.boost_pressed.connect(_on_boost_pressed)
```

Add handler:
```gdscript
func _on_boost_pressed(index: int) -> void:
    if not _is_level_active:
        return
    var used: bool = _boost_manager.use_boost(index, _current_word_index)
    if used:
        _boost_panel.disable_boost(index)
        # Check if it was a no-obstacle bonus
        var boost_id = _boost_manager.get_loadout()[index]
        var counter = _boost_manager._get_counter_type(boost_id)
        if counter == "" or not _obstacle_manager.has_obstacle_type(_current_word_index, counter):
            _score += 500
            _update_score_display()
            EventBus.score_updated.emit(_score)
```

### Task 10: Handle zero_point_completed signal

**File:** `scripts/screens/gameplay_screen.gd` (EDIT)

When building word rows, also connect `zero_point_completed`:
```gdscript
word_row.zero_point_completed.connect(_on_word_zero_point_completed.bind(i))
```

Add handler:
```gdscript
func _on_word_zero_point_completed(word_index: int) -> void:
    _words_completed += 1
    # No score awarded
    _update_word_count()
    EventBus.word_completed.emit(word_index)
    if word_index == _level_data.word_pairs.size() - 1:
        _level_complete()
    elif word_index == 12:
        _check_bonus_gate()
    else:
        _advance_to_next_word(word_index + 1)
```

### Task 11: Add all obstacle types to test level

**File:** `data/levels/test_level_01.tres` (EDIT)

Add obstacle configs:
- Padlock on word 5 (from 04-01)
- Random Blocks on word 8 with block_count = 2
- Sand targeting words 10-11 with trickle_interval = 4.0

---

## Verification

1. Padlock on word 5: locks word, auto-unlocks when word 4 solved
2. Random Blocks on word 8: 2 slots fill with blocks on arrival, remaining slots accept input
3. Sand on words 10-11: slots gradually fill with sand every 4 seconds
4. Lock Key boost on a non-padlocked word: grants +500 score
5. Block Breaker on word 8: clears all blocks
6. Bucket of Water: clears sand from affected words
7. Using a boost disables its button
