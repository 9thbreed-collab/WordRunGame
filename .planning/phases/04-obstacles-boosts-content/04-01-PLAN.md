# Plan 04-01: Obstacle System Foundation + Padlock

**Phase:** 04-obstacles-boosts-content
**Scope:** Resource-based obstacle architecture, ObstacleManager, LetterSlot/WordRow extensions, Padlock obstacle as template implementation
**Requirements:** OBST-01, OBST-02, OBST-05 (partial), OBST-06, OBST-07

---

## Context

The obstacle system uses a resource-based plugin pattern so new obstacle types require only a config resource + visual scene -- no new code paths. Padlock is built first as the template to validate the architecture.

### Key Existing Files

| File | Role |
|------|------|
| `scripts/ui/letter_slot.gd` | LetterSlot with State enum {EMPTY, FILLED, CORRECT, INCORRECT} |
| `scripts/ui/word_row.gd` | WordRow with handle_input(), activate/deactivate, _is_active flag |
| `scripts/screens/gameplay_screen.gd` | Orchestration: _on_word_completed(), _advance_to_next_word() |
| `scripts/autoloads/event_bus.gd` | Signal relay -- needs obstacle/boost signals |
| `scripts/resources/level_data.gd` | LevelData resource -- needs obstacle_configs array |

---

## Tasks

### Task 1: Create ObstacleConfig resource

**File:** `scripts/resources/obstacle_config.gd` (NEW)

```gdscript
class_name ObstacleConfig
extends Resource

@export var obstacle_type: String = ""  # "padlock", "random_blocks", "sand"
@export var display_name: String = ""
@export var word_index: int = 0  # Which word this obstacle targets
@export var trigger_type: String = "word_start"  # "word_start" or "level_start"
@export var delay_seconds: float = 0.0
@export var effect_data: Dictionary = {}  # Type-specific params (block_count, etc.)
```

No `visual_scene` field -- obstacle visuals are handled by the obstacle scripts themselves (they modify the existing WordRow/LetterSlot nodes rather than overlaying separate scenes). This avoids scene management complexity.

### Task 2: Create ObstacleBase abstract base class

**File:** `scripts/gameplay/obstacle_base.gd` (NEW)

```gdscript
class_name ObstacleBase
extends Node

signal obstacle_activated
signal obstacle_cleared

var config: ObstacleConfig
var _target_word_row  # WordRow reference (untyped to avoid circular dependency)

func setup(obstacle_config: ObstacleConfig, word_row) -> void:
    config = obstacle_config
    _target_word_row = word_row

## Override in subclasses
func activate() -> void:
    obstacle_activated.emit()

## Override in subclasses
func clear() -> void:
    obstacle_cleared.emit()

## Override if obstacle blocks input
func blocks_input() -> bool:
    return false
```

### Task 3: Create ObstacleManager

**File:** `scripts/gameplay/obstacle_manager.gd` (NEW)

ObstacleManager orchestrates obstacle lifecycle:
- `load_level_obstacles(level_data)` -- reads obstacle_configs from LevelData
- `check_trigger(word_index, trigger_type)` -- spawns obstacles when conditions match
- `clear_obstacle(word_index, boost_type)` -- clears obstacle at word_index
- `has_obstacle(word_index)` -- check if word has active obstacle
- `has_obstacle_type(word_index, type)` -- check for specific type
- `get_obstacle(word_index)` -- get active obstacle at word_index

Internal dictionary: `_active_obstacles: Dictionary = {}` mapping word_index -> ObstacleBase.

Obstacle instantiation uses a factory match on `config.obstacle_type`:
```gdscript
func _create_obstacle(config: ObstacleConfig) -> ObstacleBase:
    match config.obstacle_type:
        "padlock":
            return PadlockObstacle.new()
        "random_blocks":
            return RandomBlocksObstacle.new()
        "sand":
            return SandObstacle.new()
        _:
            push_warning("Unknown obstacle type: " + config.obstacle_type)
            return null
```

Note: While a pure plugin architecture would use PackedScene, the factory match is simpler and the roadmap only defines 3 obstacle types. OBST-07 is satisfied because adding a type means adding one match arm + one script file -- no changes to existing obstacle code.

### Task 4: Add obstacle signals to EventBus

**File:** `scripts/autoloads/event_bus.gd` (EDIT)

Add after existing signals:
```gdscript
# --- Obstacle signals ---
signal obstacle_triggered(word_index: int, obstacle_type: String)
signal obstacle_cleared(word_index: int, obstacle_type: String)

# --- Boost signals ---
signal boost_used(boost_type: String, word_index: int)
```

### Task 5: Extend LetterSlot with LOCKED state

**File:** `scripts/ui/letter_slot.gd` (EDIT)

Add LOCKED to State enum:
```gdscript
enum State { EMPTY, FILLED, CORRECT, INCORRECT, LOCKED }
```

Add `_style_locked` StyleBoxFlat (dark gray bg, dim border).

Add `_is_locked: bool = false` var.

Add functions:
```gdscript
func set_locked(locked: bool) -> void:
    _is_locked = locked
    if locked:
        set_state(State.LOCKED)
    else:
        set_state(State.EMPTY)

func can_accept_input() -> bool:
    return not _is_locked
```

Update `set_state()` match block with LOCKED case.

### Task 6: Extend WordRow with lock support

**File:** `scripts/ui/word_row.gd` (EDIT)

Add `_is_locked: bool = false` var.

Add functions:
```gdscript
func set_locked(locked: bool) -> void:
    _is_locked = locked
    for slot in _letter_slots:
        slot.set_locked(locked)
    if locked:
        modulate = Color(0.5, 0.5, 0.5, 0.7)
    elif _is_active:
        modulate = Color(1.0, 1.0, 1.0, 1.0)

func is_locked() -> bool:
    return _is_locked
```

Guard `handle_input()` to reject input when locked:
```gdscript
if not _is_active or _is_locked or _current_index >= _solution_word.length():
    return false
```

### Task 7: Implement PadlockObstacle

**File:** `scripts/gameplay/obstacles/padlock_obstacle.gd` (NEW)

```gdscript
class_name PadlockObstacle
extends ObstacleBase

func activate() -> void:
    _target_word_row.set_locked(true)
    EventBus.obstacle_triggered.emit(config.word_index, "padlock")
    obstacle_activated.emit()

func clear() -> void:
    _target_word_row.set_locked(false)
    EventBus.obstacle_cleared.emit(config.word_index, "padlock")
    obstacle_cleared.emit()

func blocks_input() -> bool:
    return true
```

### Task 8: Extend LevelData with obstacle_configs

**File:** `scripts/resources/level_data.gd` (EDIT)

Add:
```gdscript
@export var obstacle_configs: Array[ObstacleConfig] = []
```

### Task 9: Wire ObstacleManager into GameplayScreen

**File:** `scenes/screens/gameplay_screen.tscn` (EDIT)

Add ObstacleManager node as child of GameplayScreen root (sibling of GameTimer, SurgeSystem):
```
[node name="ObstacleManager" type="Node" parent="."]
unique_name_in_owner = true
script = ExtResource("obstacle_manager_script")
```

**File:** `scripts/screens/gameplay_screen.gd` (EDIT)

Add `@onready var _obstacle_manager: Node = %ObstacleManager`.

In `_ready()`, after building word rows:
```gdscript
_obstacle_manager.load_level_obstacles(_level_data, _word_rows)
```

In `_on_word_completed(word_index)`, after existing logic but before `_advance_to_next_word`:
```gdscript
# Check if next word is padlocked -- auto-unlock when previous word solved
var next_index = word_index + 1
if next_index < _word_rows.size():
    _obstacle_manager.check_trigger(next_index, "word_start")
    if _obstacle_manager.has_obstacle_type(next_index, "padlock"):
        _obstacle_manager.clear_obstacle(next_index)
```

In `_advance_to_next_word()`, trigger "word_start" obstacles for the new word:
```gdscript
_obstacle_manager.check_trigger(next_index, "word_start")
```

### Task 10: Add padlock obstacle to test level

**File:** `data/levels/test_level_01.tres` (EDIT)

Add an ObstacleConfig sub_resource for a padlock on word 5:
```
[sub_resource type="Resource" id="Obstacle_1"]
script = ExtResource("obstacle_config_script")
obstacle_type = "padlock"
display_name = "Padlock"
word_index = 5
trigger_type = "word_start"
delay_seconds = 0.0
effect_data = {}
```

Add to resource: `obstacle_configs = Array[Resource]([SubResource("Obstacle_1")])`

---

## Verification

1. Launch game, progress to word 5 -- it should appear locked (dark gray, dimmed)
2. Solve word 4 -- word 5 should auto-unlock and become active
3. Typing on a locked word should have no effect
4. ObstacleManager can report `has_obstacle(5)` returns true before clearing, false after
