---
phase: 02-core-puzzle-loop
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/ui/letter_slot.gd
  - scenes/ui/letter_slot.tscn
  - scripts/ui/word_row.gd
  - scenes/ui/word_row.tscn
autonomous: true

must_haves:
  truths:
    - "A reusable LetterSlot scene exists with 4 visual states (EMPTY, FILLED, CORRECT, INCORRECT)"
    - "A reusable WordRow scene dynamically generates LetterSlots based on a word"
    - "WordRow processes letter input, provides visual feedback for incorrect letters, and detects word completion"
    - "Shake animation plays on incorrect input"
  artifacts:
    - path: "scenes/ui/letter_slot.tscn"
      provides: "Single stateful letter slot UI component"
    - path: "scripts/ui/letter_slot.gd"
      provides: "Logic for managing LetterSlot visual states"
    - path: "scenes/ui/word_row.tscn"
      provides: "Word row with clue label and dynamic letter slots"
    - path: "scripts/ui/word_row.gd"
      provides: "Input handling, completion detection, shake feedback"
  key_links:
    - from: "scripts/ui/word_row.gd"
      to: "scenes/ui/letter_slot.tscn"
      via: "WordRow instances LetterSlot scenes to build the answer field"
---

<objective>
Build the core visual building blocks of the puzzle: individual letter slots and the word rows that contain them. These are modular, reusable components that dynamically build the puzzle view for any level. Focuses on local component logic including input validation and visual feedback.

Output: LetterSlot and WordRow scenes with scripts, supporting all visual states and input handling.
</objective>

<execution_context>
@/Users/nathanielgiddens/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanielgiddens/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-puzzle-loop/02-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LetterSlot scene and script</name>
  <files>
    scenes/ui/letter_slot.tscn
    scripts/ui/letter_slot.gd
  </files>
  <action>
    Create LetterSlot scene:
    1. Create `scenes/ui/letter_slot.tscn` with PanelContainer as root node
    2. Set custom_minimum_size to Vector2(64, 72) for readable letter display
    3. Add a Label child, centered horizontally and vertically
    4. Set Label font size large enough to read (32-36px)

    Create LetterSlot script:
    1. Create `scripts/ui/letter_slot.gd` attached to root PanelContainer
    2. Define `class_name LetterSlot extends PanelContainer`
    3. Define `enum State { EMPTY, FILLED, CORRECT, INCORRECT }`
    4. Store reference to child Label via @onready
    5. Create StyleBoxFlat resources programmatically for each state:
       - EMPTY: light gray border (#CCCCCC), transparent fill
       - FILLED: white background, dark border
       - CORRECT: green background (#4CAF50)
       - INCORRECT: red background (#F44336)
    6. Implement `set_state(new_state: State)` that applies the matching StyleBox
    7. Implement `set_letter(character: String)` that sets Label text to uppercase
    8. Implement `get_letter() -> String` that returns current letter
    9. Implement `clear()` that resets to EMPTY state with no text
  </action>
  <verify>
    1. scenes/ui/letter_slot.tscn exists with PanelContainer root + Label child
    2. scripts/ui/letter_slot.gd has State enum, set_state(), set_letter(), get_letter(), clear()
    3. All 4 states produce different visual appearances
  </verify>
  <done>
    - LetterSlot scene and script created
    - 4 visual states working (EMPTY, FILLED, CORRECT, INCORRECT)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WordRow scene and script</name>
  <files>
    scenes/ui/word_row.tscn
    scripts/ui/word_row.gd
  </files>
  <action>
    Create WordRow scene:
    1. Create `scenes/ui/word_row.tscn` with HBoxContainer as root
    2. Add a Label child named "ClueLabel" for displaying word_a (the clue)
    3. Set ClueLabel minimum width (~120px), bold font, right-aligned
    4. Leave space after ClueLabel for dynamically-added LetterSlots

    Create WordRow script:
    1. Create `scripts/ui/word_row.gd` attached to root HBoxContainer
    2. Preload letter_slot scene: `const LetterSlotScene = preload("res://scenes/ui/letter_slot.tscn")`
    3. Define `signal word_completed`
    4. Store: solution_word (String), current_index (int), letter_slots (Array[LetterSlot]), is_active (bool)
    5. Implement `set_word_pair(pair: WordPair)`:
       - Set ClueLabel.text = pair.word_a.to_upper()
       - Store pair.word_b.to_upper() as solution_word
       - Remove any existing LetterSlots
       - For each character in word_b: instance LetterSlotScene, add as child, append to letter_slots array
       - Reset current_index to 0
    6. Implement `handle_input(letter: String) -> bool`:
       - If not is_active or current_index >= solution_word.length(): return false
       - Compare letter.to_upper() with solution_word[current_index]
       - If correct: set slot to FILLED state with letter, advance current_index
         - If current_index == solution_word.length(): mark all CORRECT, emit word_completed
         - Return true
       - If incorrect: briefly flash slot INCORRECT, call shake(), return false
    7. Implement `delete_letter()`:
       - If current_index > 0: decrement current_index, clear that slot
    8. Implement `activate()` / `deactivate()`:
       - activate: is_active = true, visual highlight (subtle border or background change)
       - deactivate: is_active = false, remove highlight
    9. Implement `shake()`:
       - Store original position.x
       - Create Tween: oscillate position.x +-15px over 0.2s total, return to original
  </action>
  <verify>
    1. scenes/ui/word_row.tscn exists with HBoxContainer root + ClueLabel
    2. scripts/ui/word_row.gd has set_word_pair(), handle_input(), delete_letter(), activate(), deactivate(), shake()
    3. WordRow dynamically creates correct number of LetterSlots from WordPair
    4. Correct input fills slots, incorrect input triggers shake
    5. word_completed signal emits when all letters correct
  </verify>
  <done>
    - WordRow scene and script created
    - Dynamic LetterSlot generation from WordPair data
    - Input handling with correct/incorrect feedback
    - Shake animation on wrong input
    - word_completed signal on full correct word
  </done>
</task>

</tasks>

<verification>
Requirements validated by this plan:
- PUZL-02: LetterSlot + WordRow show blank letter slots filled one at a time
- PUZL-05: Incorrect letter input triggers shake animation and INCORRECT visual state
</verification>

<success_criteria>
1. letter_slot.tscn and letter_slot.gd manage 4 visual states correctly
2. word_row.tscn and word_row.gd dynamically generate LetterSlots from WordPair
3. WordRow handles letter input with correct/incorrect feedback
4. Shake animation triggers on incorrect input
5. word_completed signal emits when word is fully solved
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-puzzle-loop/02-02-SUMMARY.md`
</output>
