---
phase: 02-core-puzzle-loop
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - scripts/ui/on_screen_keyboard.gd
  - scenes/ui/on_screen_keyboard.tscn
  - scripts/screens/gameplay_screen.gd
  - scenes/screens/gameplay_screen.tscn
autonomous: true

must_haves:
  truths:
    - "A playable gameplay screen exists with scrolling word rows, on-screen keyboard, and countdown timer"
    - "Player inputs letters via custom keyboard, routed to the active WordRow"
    - "Correctly solved words trigger auto-scroll to next word via Tween animation"
    - "Countdown timer displays MM:SS and triggers level_failed at zero"
    - "Bonus words (indices 12-14) are playable with stub gate for Phase 3 surge integration"
  artifacts:
    - path: "scenes/ui/on_screen_keyboard.tscn"
      provides: "Reusable QWERTY keyboard component"
    - path: "scripts/ui/on_screen_keyboard.gd"
      provides: "Key press signal emission"
    - path: "scenes/screens/gameplay_screen.tscn"
      provides: "Main gameplay screen layout"
    - path: "scripts/screens/gameplay_screen.gd"
      provides: "Central puzzle loop orchestration"
  key_links:
    - from: "scripts/screens/gameplay_screen.gd"
      to: "scripts/ui/on_screen_keyboard.gd"
      via: "Connects to key_pressed signal for input routing"
    - from: "scripts/screens/gameplay_screen.gd"
      to: "scripts/ui/word_row.gd"
      via: "Instances WordRows, connects to word_completed signals"
    - from: "scripts/screens/gameplay_screen.gd"
      to: "scripts/autoloads/event_bus.gd"
      via: "Emits level_completed, level_failed, word_completed, letter_input"
---

<objective>
Assemble the data models and UI components into a playable gameplay screen. Builds the on-screen keyboard, creates the GameplayScreen that orchestrates the entire puzzle loop -- loading level data, routing keyboard input, managing the timer, auto-scrolling between words, and signaling level completion or failure.

Output: Functional GameplayScreen with keyboard, scrolling word display, timer, and complete puzzle loop.
</objective>

<execution_context>
@/Users/nathanielgiddens/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathanielgiddens/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-puzzle-loop/02-RESEARCH.md
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-core-puzzle-loop/02-01-SUMMARY.md
@.planning/phases/02-core-puzzle-loop/02-02-SUMMARY.md
@scripts/autoloads/event_bus.gd
@scripts/autoloads/game_manager.gd
@scenes/ui/banner_ad_region.tscn
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create On-Screen Keyboard</name>
  <files>
    scenes/ui/on_screen_keyboard.tscn
    scripts/ui/on_screen_keyboard.gd
  </files>
  <action>
    Create keyboard scene:
    1. Create `scenes/ui/on_screen_keyboard.tscn` with VBoxContainer root
    2. Set custom_minimum_size.y = 280 (fixed keyboard height)
    3. Add 3 HBoxContainer children for QWERTY rows:
       - Row 1: Q W E R T Y U I O P (10 keys)
       - Row 2: A S D F G H J K L (9 keys)
       - Row 3: Z X C V B N M DEL (8 keys)
    4. Each key is a Button node with text set to the letter
    5. Set each Button custom_minimum_size to Vector2(88, 72) -- fits 10 keys at 1080px with spacing
    6. DEL button should be wider (~140px) and use a distinct style
    7. Set HBoxContainer alignment to CENTER
    8. Use size_flags_horizontal = SIZE_EXPAND_FILL on buttons for even distribution

    Create keyboard script:
    1. Create `scripts/ui/on_screen_keyboard.gd` on root VBoxContainer
    2. Declare `signal key_pressed(key: String)`
    3. In _ready(): iterate all HBoxContainer children, then all Button children
       - Connect each button.pressed to _on_button_pressed.bind(button.text)
    4. _on_button_pressed(char: String): emit key_pressed(char)
  </action>
  <verify>
    1. on_screen_keyboard.tscn has 3 rows of buttons in QWERTY layout + DEL
    2. Script emits key_pressed signal with the correct letter for each button
    3. All buttons are at least 72px tall (exceeds 48dp)
  </verify>
  <done>
    - On-screen keyboard scene and script created
    - QWERTY layout with DEL key
    - key_pressed signal working
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GameplayScreen</name>
  <files>
    scenes/screens/gameplay_screen.tscn
    scripts/screens/gameplay_screen.gd
  </files>
  <action>
    Create GameplayScreen scene:
    1. Create `scenes/screens/gameplay_screen.tscn` with Control root (full rect anchors)
    2. Add MainVBox (VBoxContainer, full rect, anchors preset = full rect)
    3. Inside MainVBox, add:
       a. HUD (HBoxContainer, custom_minimum_size.y = 60):
          - TimerLabel (Label, unique name %TimerLabel) -- shows MM:SS
          - Spacer (Control, size_flags_horizontal = EXPAND_FILL)
          - WordCountLabel (Label, unique name %WordCountLabel) -- shows "3/15"
       b. WordDisplay (ScrollContainer, size_flags_vertical = EXPAND_FILL):
          - WordRows (VBoxContainer, unique name %WordRows)
          - Disable horizontal scrollbar, disable manual vertical scrolling if possible
       c. OnScreenKeyboard (instance of on_screen_keyboard.tscn, unique name %Keyboard)
    4. Add BannerAdRegion (instance of banner_ad_region.tscn) as last child of MainVBox
    5. Add GameTimer (Timer node, unique name %GameTimer) as child of root

    Create GameplayScreen script:
    1. Create `scripts/screens/gameplay_screen.gd` on root Control
    2. @onready references for: TimerLabel, WordCountLabel, WordRows container, Keyboard, GameTimer
    3. Preload WordRow scene: `const WordRowScene = preload("res://scenes/ui/word_row.tscn")`
    4. Variables: level_data (LevelData), word_rows (Array), current_word_index (int), time_remaining (int), is_level_active (bool)

    5. In _ready():
       a. Load test level: level_data = load("res://data/levels/test_level_01.tres")
       b. Setup timer: GameTimer.wait_time = 1.0, GameTimer.timeout.connect(_on_timer_tick)
       c. Connect keyboard: Keyboard.key_pressed.connect(_on_key_pressed)
       d. Call _build_word_rows()
       e. Set time_remaining = level_data.time_limit_seconds
       f. _update_timer_display()
       g. Activate first word row
       h. Start GameTimer
       i. Call GameManager.transition_to(GameManager.AppState.PLAYING)

    6. _build_word_rows():
       - For each word_pair in level_data.word_pairs:
         - Instance WordRowScene, call set_word_pair(word_pair)
         - Connect word_completed signal to _on_word_completed.bind(index)
         - Add to WordRows container
         - Store in word_rows array

    7. _on_key_pressed(key: String):
       - If not is_level_active: return
       - If key == "DEL": word_rows[current_word_index].delete_letter()
       - Else:
         - var correct = word_rows[current_word_index].handle_input(key)
         - EventBus.letter_input.emit(key, correct)

    8. _on_word_completed(word_index: int):
       - EventBus.word_completed.emit(word_index)
       - _update_word_count()
       - If word_index == level_data.word_pairs.size() - 1: _level_complete()
       - Elif word_index == 11: _check_bonus_gate() -- stub: always proceed
       - Else: _advance_to_next_word(word_index + 1)

    9. _advance_to_next_word(next_index: int):
       - word_rows[current_word_index].deactivate()
       - current_word_index = next_index
       - word_rows[current_word_index].activate()
       - Tween scroll: get WordDisplay ScrollContainer, tween scroll_vertical to word_rows[next_index].position.y over 0.4s

    10. _check_bonus_gate():
        - # STUB: Phase 3 will check surge momentum here
        - # For now, always allow bonus words
        - _advance_to_next_word(12)

    11. _on_timer_tick():
        - time_remaining -= 1
        - _update_timer_display()
        - If time_remaining <= 0: _level_failed()

    12. _update_timer_display():
        - var minutes = time_remaining / 60
        - var seconds = time_remaining % 60
        - TimerLabel.text = "%02d:%02d" % [minutes, seconds]

    13. _update_word_count():
        - WordCountLabel.text = "%d/%d" % [current_word_index + 1, level_data.word_pairs.size()]

    14. _level_complete():
        - is_level_active = false
        - GameTimer.stop()
        - EventBus.level_completed.emit()

    15. _level_failed():
        - is_level_active = false
        - GameTimer.stop()
        - EventBus.level_failed.emit()
  </action>
  <verify>
    1. GameplayScreen scene has HUD, ScrollContainer with WordRows, keyboard, banner region, Timer
    2. Level loads and WordRows are populated from test_level_01.tres
    3. Keyboard input routes to active WordRow
    4. Correct word triggers auto-scroll to next row
    5. Timer counts down and displays MM:SS
    6. level_completed fires when all words solved
    7. level_failed fires when timer hits 0
    8. Bonus gate stub exists at word index 11
  </verify>
  <done>
    - GameplayScreen scene and script created
    - Full puzzle loop: load level, input, auto-submit, scroll, timer, completion/failure
    - Bonus word stub ready for Phase 3 surge integration
  </done>
</task>

</tasks>

<verification>
Requirements validated by this plan:
- PUZL-01: ScrollContainer with VBoxContainer displays 4-5 word rows at a time
- PUZL-04: Correct word auto-submits and view auto-scrolls to next word
- PUZL-06: On-screen keyboard captures player input
- PUZL-08: Bonus words included with stub gate at word 12 (Phase 3 plugs in surge check)
- PUZL-09: Countdown timer visible in HUD, MM:SS format
- PUZL-10: Keyboard buttons at 88x72px minimum (exceeds 48dp)
</verification>

<success_criteria>
1. On-screen keyboard created with QWERTY layout and DEL key, emits key_pressed signal
2. GameplayScreen loads test level and creates WordRow instances
3. Keyboard input routes to active WordRow correctly
4. Completing a word auto-scrolls to next word with Tween animation
5. Timer counts down from level time limit, displays MM:SS
6. level_completed emits when all 15 words solved
7. level_failed emits when timer reaches 0
8. Bonus gate stub at word 12 always allows progression
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-puzzle-loop/02-03-SUMMARY.md`
</output>
